# -*- coding: utf-8 -*-
"""Asistente Sammy para Hotel - Notebook de Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PBsRbyUyk3cMY2paN76vht1ONCrUioVi

# Proyecto: Asistente Virtual "Sammy" para el Hotel Para√≠so Caribe√±o

**Creado por: Grupo #3**

## 1. Introducci√≥n

Este proyecto consiste en el desarrollo de "Sammy", un asistente virtual inteligente dise√±ado para el Hotel Para√≠so Caribe√±o, ubicado en Santa Marta. Sammy tiene como objetivo principal mejorar la experiencia del cliente al proporcionar informaci√≥n, gestionar consultas y ayudar con tareas como la verificaci√≥n de usuarios, el registro y la creaci√≥n de solicitudes de reserva.

El asistente ha sido desarrollado en un entorno de Google Colab, utilizando Python como lenguaje de programaci√≥n principal y aprovechando las capacidades avanzadas del modelo de lenguaje grande (LLM) Gemini de Google para la comprensi√≥n del lenguaje natural y la generaci√≥n de respuestas.

## 2. Objetivos del Proyecto

* Crear un asistente conversacional capaz de entender y responder a las solicitudes de los usuarios de manera natural.
* Integrar el asistente con una base de datos (MongoDB Atlas) para gestionar informaci√≥n de usuarios, paquetes, servicios y reservas.
* Implementar funcionalidades clave como:
    * Bienvenida y recolecci√≥n de datos del usuario.
    * Verificaci√≥n de usuarios existentes y registro de nuevos usuarios.
    * Consulta de informaci√≥n sobre paquetes de alojamiento, habitaciones y servicios/tours adicionales.
    * Creaci√≥n de solicitudes de reserva, incluyendo la selecci√≥n de paquetes y servicios.
    * Consulta del estado de reservas existentes.
    * Actualizaci√≥n del estado de las reservas.
* Proporcionar una interfaz de usuario interactiva dentro del notebook de Google Colab utilizando `ipywidgets` para facilitar la demostraci√≥n y la interacci√≥n.
* Demostrar el uso de la t√©cnica de "function calling" (uso de herramientas) con el LLM Gemini para realizar acciones espec√≠ficas y obtener datos de fuentes externas (la base de datos).

## 3. Tecnolog√≠as Utilizadas

* **Lenguaje de Programaci√≥n:** Python
* **Entorno de Desarrollo:** Google Colaboratory (Colab)
* **Modelo de Lenguaje (IA):** API de Gemini (espec√≠ficamente, el modelo `gemini-1.5-flash-latest` o similar) a trav√©s de la librer√≠a `google-generativeai`.
* **Base de Datos:** MongoDB Atlas (NoSQL, servicio en la nube), interactuando mediante la librer√≠a `pymongo`.
* **Interfaz de Usuario en Colab:** `ipywidgets` para crear una experiencia de chat interactiva dentro del notebook.
* **Manejo de Credenciales:** `google.colab.userdata` para acceder a API keys de forma segura.
* **Otras Librer√≠as Python:**
    * `os`: Para interactuar con el sistema operativo (no se usa extensivamente en la versi√≥n Colab, m√°s relevante para el backend Flask).
    * `datetime`: Para manejar fechas y horas.
    * `uuid`: Para generar identificadores √∫nicos.
    * `html`: Para escapar texto HTML en la interfaz de usuario.

## 4. Estructura del Notebook de Colab

El proyecto en Google Colab est√° organizado en varias celdas, cada una con una responsabilidad espec√≠fica:

1.  **Celda 1: Instalaci√≥n de Librer√≠as:**
    * Instala las dependencias necesarias (`google-generativeai`, `pymongo`, `ipywidgets`).
2.  **Celda 2: Importaciones Esenciales y Configuraci√≥n Inicial:**
    * Importa todos los m√≥dulos de Python requeridos.
    * Define variables globales para la configuraci√≥n (URIs de conexi√≥n, nombres de colecciones, API keys le√≠das desde los Secrets de Colab).
    * Inicializa variables globales para los objetos de base de datos y el modelo de IA.
    * Define el `DEBUG_MODE` para controlar la verbosidad de los logs.
3.  **Celda 3: Funci√≥n Auxiliar de Serializaci√≥n:**
    * Contiene la funci√≥n `_serializar_documento_para_llm`, que es crucial para convertir los datos de MongoDB (especialmente `ObjectId` y `datetime`) a un formato que el LLM pueda procesar sin errores.
4.  **Celda 4: Definici√≥n de Funciones Herramienta para Sammy:**
    * Aqu√≠ se definen todas las funciones Python que Sammy (el LLM) puede "llamar". Estas funciones son las "habilidades" de Sammy y le permiten interactuar con la base de datos o realizar c√°lculos. Ejemplos: `Bienvenida_cliente`, `verificar_o_registrar_usuario`, `listar_paquetes_disponibles`, `crear_reserva`, etc.
    * Se incluye la lista `herramientas_disponibles_colab` que agrupa todas estas funciones para pasarlas al modelo Gemini.
5.  **Celda 5: Funci√≥n de Inicializaci√≥n Principal (`inicializar_app_colab`):**
    * Esta funci√≥n se encarga de:
        * Establecer la conexi√≥n con MongoDB Atlas.
        * Configurar el cliente de Gemini con la API Key.
        * Crear la instancia del `GenerativeModel` de Gemini, pas√°ndole las `herramientas_disponibles_colab` y la `system_instruction` (el prompt de sistema que define la personalidad y el comportamiento de Sammy).
        * Iniciar la sesi√≥n de chat (`chat_session_sammy`).
6.  **Celda 6: Funci√≥n para Procesar Mensajes (`procesar_mensaje_colab`):**
    * Esta es la funci√≥n central que maneja cada turno de la conversaci√≥n.
    * Toma el mensaje del usuario.
    * Implementa la l√≥gica para mapear selecciones num√©ricas del usuario a IDs de √≠tems (si Sammy acaba de presentar una lista).
    * Env√≠a el mensaje al `chat_session_sammy`.
    * Maneja el bucle de "function calling": si el LLM decide usar una herramienta, esta funci√≥n la ejecuta y env√≠a el resultado de vuelta al LLM.
    * Extrae la respuesta final de texto del LLM para mostrarla al usuario.
7.  **Celda 7: Interfaz Gr√°fica con `ipywidgets` y L√≥gica de Chat:**
    * Define los estilos HTML para la interfaz de chat.
    * Crea los widgets: un √°rea para mostrar la conversaci√≥n, un campo de texto para la entrada del usuario y un bot√≥n de env√≠o.
    * Implementa la l√≥gica de la UI (`add_message_to_ui`, `on_send_button_clicked_ui`) para mostrar la conversaci√≥n y manejar las interacciones del usuario.
    * Llama a `inicializar_app_colab()` y, si tiene √©xito, muestra la interfaz de chat e inicia la primera interacci√≥n con Sammy.

## 5. Funcionamiento del Asistente (Interacci√≥n con Gemini)

El n√∫cleo de la inteligencia de Sammy reside en el modelo Gemini y su capacidad de "function calling":

1.  **Prompt de Sistema (`system_instruction`):** Al inicializar el modelo Gemini, se le proporciona una instrucci√≥n de sistema detallada. Esta instrucci√≥n define la personalidad de Sammy (amigable, profesional), su rol (asistente del Hotel Para√≠so Caribe√±o), sus objetivos, y, muy importante, c√≥mo y cu√°ndo debe utilizar las diferentes funciones herramienta que se le han proporcionado.
2.  **Mensaje del Usuario:** Cuando el usuario env√≠a un mensaje, este se pasa al modelo Gemini.
3.  **Decisi√≥n del LLM:** Bas√°ndose en el mensaje del usuario, el historial de la conversaci√≥n y la instrucci√≥n de sistema, el LLM decide c√≥mo responder. Puede:
    * Responder directamente con texto.
    * Decidir que necesita m√°s informaci√≥n o realizar una acci√≥n, para lo cual "llama" a una de las funciones herramienta definidas en Python.
4.  **Ejecuci√≥n de la Herramienta (Python):** Si el LLM decide llamar a una herramienta, el c√≥digo Python (en `procesar_mensaje_colab`) recibe el nombre de la funci√≥n y los argumentos que el LLM ha extra√≠do de la conversaci√≥n. El c√≥digo Python ejecuta la funci√≥n correspondiente (ej., una consulta a MongoDB).
5.  **Resultado de la Herramienta al LLM:** El resultado de la funci√≥n Python (generalmente un diccionario con un `status` y datos) se env√≠a de vuelta al LLM.
6.  **Respuesta Final del LLM:** Con la informaci√≥n obtenida de la herramienta (o si no necesit√≥ una), el LLM formula una respuesta en lenguaje natural para el usuario. El `system_instruction` le indica expl√≠citamente que NO muestre el JSON crudo de los `tool_outputs`.

Este ciclo se repite para cada turno de la conversaci√≥n.

## 6. C√≥mo Usar el Notebook de Colab

1.  **Configurar Secrets:** Antes de ejecutar, aseg√∫rate de haber configurado las siguientes variables en los "Secrets" de Google Colab (icono de llave üîë en el panel izquierdo):
    * `MONGODB_ATLAS_URI`: Tu cadena de conexi√≥n a MongoDB Atlas.
    * `GEMINI_API_KEY`: Tu clave API para los modelos Gemini de Google AI Studio.
2.  **Ejecutar Celdas en Orden:** Es crucial ejecutar todas las celdas del notebook en orden, desde la Celda 1 hasta la Celda 7.
    * La Celda 1 instala las librer√≠as.
    * Las Celdas 2-6 definen todas las configuraciones, funciones y l√≥gica necesarias.
    * La Celda 7 es la que finalmente inicializa la aplicaci√≥n y muestra la interfaz de chat interactiva.
3.  **Interactuar con Sammy:** Una vez que la Celda 7 se ejecuta y muestra el mensaje "¬°Todo listo!...", podr√°s usar la interfaz de chat (el campo de texto y el bot√≥n "Enviar") para hablar con Sammy.
4.  **Modo de Depuraci√≥n (`DEBUG_MODE`):** En la Celda 2, puedes cambiar `DEBUG_MODE = True` si deseas ver los logs internos de las llamadas a funciones y sus resultados en la salida de la celda (debajo de la interfaz de chat). Para una presentaci√≥n limpia, mantenlo en `False`.
5.  **Finalizar:** Escribe "salir" en el chat para terminar la conversaci√≥n. La conexi√≥n a MongoDB se cerrar√° si se implementa un bot√≥n o l√≥gica para ello, o al finalizar la sesi√≥n de Colab.

## 7. Posibles Mejoras Futuras

* Implementaci√≥n de una l√≥gica de disponibilidad de habitaciones m√°s robusta.
* C√°lculo de precios finales m√°s preciso (considerando temporadas, ofertas, etc.).
* Gesti√≥n de sesiones de chat m√°s avanzada si se llevara a un entorno multiusuario.
* Integraci√≥n con un frontend web externo (React, Vue) y un backend Flask/FastAPI desplegado en la nube.
* A√±adir m√°s herramientas para Sammy (ej. modificar reservas, obtener informaci√≥n tur√≠stica de Santa Marta, etc.).

---

Este proyecto demuestra una aplicaci√≥n pr√°ctica de los modelos de lenguaje grandes con capacidad de uso de herramientas para crear asistentes virtuales funcionales y √∫tiles.
"""

# Celda 1: Instalaci√≥n de Librer√≠as
# ---------------------------------------------------------------------------
# Primero, me aseguro de que todas las librer√≠as que necesito est√©n instaladas
# en el entorno de Colab. El -q hace que la instalaci√≥n sea silenciosa.
!pip install -q google-generativeai pymongo python-dotenv ipywidgets

# Celda 2: Importaciones Esenciales y Configuraci√≥n Inicial
# ---------------------------------------------------------------------------
print("Colab Notebook: Cargando m√≥dulos y configuraciones iniciales...")

import os
import pymongo # Para la base de datos MongoDB
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi
from datetime import datetime # Para manejar fechas y horas
import uuid # Para generar IDs √∫nicos para las reservas
import google.generativeai as genai # La librer√≠a de Gemini
from google.ai import generativelanguage as glm # Para construir el FunctionResponse
from google.colab import userdata # Para obtener mis API keys de los Secrets de Colab
import html # Para escapar HTML en la UI y prevenir XSS b√°sico

# Importaciones para la Interfaz Gr√°fica con ipywidgets
import ipywidgets as widgets
from IPython.display import display, HTML

# --- Configuraci√≥n de Mis Variables Globales ---
# Obtengo mis credenciales de los Secrets de Colab.
# Es importante tener MONGODB_ATLAS_URI y GEMINI_API_KEY configurados all√≠.
MONGODB_URI = userdata.get('MONGODB_ATLAS_URI')
GEMINI_API_KEY = userdata.get('GEMINI_API_KEY')

# Nombres que he decidido para mi base de datos y colecciones.
DB_NAME_PRINCIPAL = "TalentoTech"
COLL_USUARIOS_NAME = "usuarios"
COLL_SERVICIOS_NAME = "servicios"
COLL_PAQUETES_NAME = "paquetes"
COLL_HABITACIONES_NAME = "habitaciones"
COLL_RESERVAS_NAME = "reservas"

# Variables que contendr√°n los objetos de conexi√≥n y el modelo de IA.
# Las inicializo a None; la funci√≥n de inicializaci√≥n se encargar√° de poblarlas.
client_mongo = None
db = None
usuarios_coll, servicios_coll, paquetes_coll, habitaciones_coll, reservas_coll = None, None, None, None, None
model_gemini = None
chat_session_sammy = None

# Estado de la sesi√≥n de chat: para recordar cosas simples durante la conversaci√≥n.
session_state = {"bienvenida_dada": False, "ultima_lista_presentada": None, "usuario_identificado": None}

# DEBUG_MODE: Si es True, se mostrar√°n prints detallados de depuraci√≥n.
# Para la presentaci√≥n, lo dejo en False para una interfaz m√°s limpia.
DEBUG_MODE = False

print("Colab Notebook: Variables globales listas.")

# Celda 3: Funci√≥n Auxiliar de Serializaci√≥n de Datos
# ---------------------------------------------------------------------------
# Esta funci√≥n me ayuda a preparar los datos que vienen de MongoDB
# para que el LLM los pueda entender bien (convirtiendo tipos especiales a strings).
def _serializar_documento_para_llm(documento: dict) -> dict:
    """
    Prepara una copia de un documento de MongoDB para ser enviado al LLM.
    Convierte ObjectId a string y objetos datetime a strings formateados (YYYY-MM-DD HH:MM:SS).
    Elimina los campos datetime originales despu√©s de crear su versi√≥n string.
    """
    if documento is None: # Manejo el caso de que el documento sea nulo.
        return {}

    doc_copia = dict(documento) # Trabajo sobre una copia para no alterar el original.

    # El _id de MongoDB es un ObjectId, lo convierto a string.
    if '_id' in doc_copia and not isinstance(doc_copia['_id'], str):
        doc_copia['_id'] = str(doc_copia['_id'])

    # Busco todos los campos que sean de tipo datetime.
    campos_fecha_a_procesar = [key for key, value in doc_copia.items() if isinstance(value, datetime)]

    # Convierto cada campo de fecha a un string formateado y elimino el original.
    for field in campos_fecha_a_procesar:
        doc_copia[f"{field}_str"] = doc_copia[field].strftime('%Y-%m-%d %H:%M:%S')
        del doc_copia[field] # Importante para evitar errores de serializaci√≥n con el LLM.

    return doc_copia

# Celda 4: Definici√≥n de Funciones Herramienta para Sammy
# ---------------------------------------------------------------------------
# Estas son las funciones que le dan "poderes" a Sammy para interactuar con mi base de datos
# y realizar las tareas que necesito. El LLM decidir√° cu√°ndo llamar a cada una.

def debug_print(mensaje: str):
    """Funci√≥n auxiliar para imprimir mensajes de depuraci√≥n solo si DEBUG_MODE es True."""
    if DEBUG_MODE:
        print(mensaje)

def Bienvenida_cliente() -> dict:
    """
    Define el saludo inicial de Sammy y c√≥mo debe proceder para identificar al usuario.
    El LLM usar√° el 'mensaje_bienvenida_llm' para hablar con el usuario.
    """
    global session_state
    debug_print("‚öôÔ∏è Colab/Sammy: LLM llam√≥ a Bienvenida_cliente()")

    # Evito que Sammy salude repetidamente si ya lo hizo y el usuario est√° identificado.
    if session_state.get("bienvenida_dada") and session_state.get("usuario_identificado"):
        debug_print("‚ÑπÔ∏è Colab/Sammy: Bienvenida ya dada y usuario identificado.")
        nombre_usuario = session_state["usuario_identificado"].get("nombre_usuario", "Cliente")
        return {
            "mensaje_bienvenida_llm": f"¬°Hola de nuevo, {nombre_usuario}! ¬øC√≥mo puedo ayudarte hoy?",
            "proceder_directo": True
        }
    # Si ya salud√≥ pero a√∫n no identifica al usuario.
    elif session_state.get("bienvenida_dada"):
        debug_print("‚ÑπÔ∏è Colab/Sammy: Bienvenida ya dada, pero usuario no identificado.")
        return {
            "mensaje_bienvenida_llm": "Para continuar, por favor, ind√≠came tu nombre completo y n√∫mero de documento.",
            "campos_requeridos_secuencia": ["nombre_completo", "numero_documento"],
            "instruccion_para_llm_despues_de_obtener_datos": "Usa 'verificar_o_registrar_usuario'.",
            "siguiente_herramienta_sugerida": "verificar_o_registrar_usuario"
        }

    # El primer saludo.
    mensaje_para_el_usuario = (
        "¬°Hola! üëã Bienvenido al sistema de asistencia del Hotel Para√≠so Caribe√±o en la hermosa Santa Marta. "
        "Soy Sammy, tu asistente virtual. Para comenzar y poder ayudarte mejor, ¬øpodr√≠as decirme tu nombre completo y luego tu n√∫mero de documento, por favor?"
    )
    session_state["bienvenida_dada"] = True
    return {
        "mensaje_bienvenida_llm": mensaje_para_el_usuario,
        "campos_requeridos_secuencia": ["nombre_completo", "numero_documento"],
        "instruccion_para_llm_despues_de_obtener_datos": "Una vez que tengas el nombre y el n√∫mero de documento, utiliza la herramienta 'verificar_o_registrar_usuario'.",
        "siguiente_herramienta_sugerida": "verificar_o_registrar_usuario"
    }

def verificar_o_registrar_usuario(numero_documento: str, nombre_completo: str = None) -> dict:
    """
    Busca al usuario en la base de datos. Si existe, devuelve sus datos.
    Si no, gu√≠a al LLM para pedir el nombre (si a√∫n no lo tiene) o para sugerir el registro.
    """
    global session_state
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a verificar_o_registrar_usuario(doc='{numero_documento}', nombre='{nombre_completo}')")
    if usuarios_coll is None: # Verifico si la conexi√≥n a la colecci√≥n de usuarios est√° activa.
        return {"status": "error_conexion_db", "mensaje_para_llm": "Lo siento, no puedo acceder a la base de datos de usuarios en este momento."}
    try:
        usuario_encontrado_raw = usuarios_coll.find_one({"numero_documento": numero_documento})
        if usuario_encontrado_raw:
            usuario_serializado = _serializar_documento_para_llm(usuario_encontrado_raw)
            nombre_display = usuario_serializado.get('nombre_usuario') or usuario_serializado.get('nombrre_usuario', 'Cliente') # Manejo el typo 'nombre'
            session_state["usuario_identificado"] = usuario_serializado # Guardo el usuario en el estado de la sesi√≥n.
            return {
                "status": "usuario_encontrado", "datos_usuario": usuario_serializado,
                "mensaje_para_llm": f"¬°Hola de nuevo, {nombre_display}! Ya te tengo en mis registros. ¬øEn qu√© te puedo ayudar hoy?"
            }
        else: # Si el usuario no se encuentra en la base de datos.
            if nombre_completo: # Si el LLM ya me pas√≥ el nombre completo.
                return {
                    "status": "usuario_no_encontrado_proceder_registro",
                    "numero_documento_a_registrar": numero_documento, "nombre_completo_a_registrar": nombre_completo,
                    "mensaje_para_llm": (
                        f"Entendido, {nombre_completo}. Como eres nuevo, voy a registrarte con el documento '{numero_documento}'. "
                        "(LLM: Llama a `registrar_nuevo_usuario` con estos datos)." # Instrucci√≥n para el LLM.
                    ),
                    "siguiente_herramienta_sugerida": "registrar_nuevo_usuario",
                    "argumentos_siguiente_herramienta": {"nombre_completo": nombre_completo, "numero_documento": numero_documento}
                }
            else: # Si solo tengo el documento y necesito el nombre para registrar.
                return {
                    "status": "usuario_no_encontrado_pedir_nombre", "numero_documento_verificado": numero_documento,
                    "mensaje_para_llm": (
                        f"Parece que el n√∫mero de documento '{numero_documento}' no est√° registrado. "
                        "Para continuar, ¬øpodr√≠as por favor indicarme tu nombre completo para registrarte?"
                    )
                }
    except Exception as e:
        debug_print(f"üî¥ Error en verificar_o_registrar_usuario: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Tuve un problema t√©cnico verificando el documento."}

def registrar_nuevo_usuario(nombre_completo: str, numero_documento: str, rol: str = "cliente") -> dict:
    """ Registra un nuevo usuario en la base de datos. """
    global session_state
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a registrar_nuevo_usuario(nombre='{nombre_completo}', doc='{numero_documento}')")
    if usuarios_coll is None:
        return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo registrar usuarios ahora (DB)." }
    try:
        # Verifico de nuevo por si acaso el flujo del LLM lo llama aunque ya exista.
        if usuarios_coll.find_one({"numero_documento": numero_documento}):
            usuario_existente_raw = usuarios_coll.find_one({"numero_documento": numero_documento})
            usuario_existente_serializado = _serializar_documento_para_llm(usuario_existente_raw or {})
            session_state["usuario_identificado"] = usuario_existente_serializado
            return {"status": "usuario_ya_existia", "datos_usuario": usuario_existente_serializado,
                    "mensaje_para_llm": f"El usuario {nombre_completo} con documento {numero_documento} ya estaba registrado. Puedes proceder con su solicitud."}

        nuevo_usuario_doc = {
            "numero_documento": numero_documento,
            "nombre_usuario": nombre_completo, # Aseguro consistencia en el nombre del campo.
            "numero_reservas_realizadas": 0,
            "rol": rol,
            "fecha_registro": datetime.now()
        }
        resultado = usuarios_coll.insert_one(dict(nuevo_usuario_doc)) # Guardo el nuevo usuario.

        # Obtengo el documento reci√©n insertado para devolverlo completo y serializado.
        usuario_insertado_confirmacion_raw = usuarios_coll.find_one({"_id": resultado.inserted_id})
        usuario_insertado_serializado = _serializar_documento_para_llm(usuario_insertado_confirmacion_raw or {})
        session_state["usuario_identificado"] = usuario_insertado_serializado # Guardo el nuevo usuario en el estado.

        return {
            "status": "usuario_registrado_exitosamente", "datos_usuario_nuevo": usuario_insertado_serializado,
            "mensaje_para_llm": (f"¬°Perfecto, {nombre_completo}! Tu registro con el n√∫mero de documento {numero_documento} fue exitoso. "
                                 "Ahora, ¬øc√≥mo puedo ayudarte con tu reserva o alguna otra consulta?")
        }
    except Exception as e:
        debug_print(f"üî¥ Error en registrar_nuevo_usuario: {str(e)}")
        return {"status": "error_registro_db", "mensaje_para_llm": f"Problema t√©cnico al registrar a {nombre_completo}."}

def listar_servicios_disponibles(tipo_servicio: str = None) -> dict:
    """
    Lista los servicios y tours, opcionalmente filtrados por tipo.
    Guarda la lista en session_state para que el usuario pueda seleccionar por n√∫mero.
    """
    global session_state
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a listar_servicios_disponibles(tipo_servicio='{tipo_servicio}')")
    if servicios_coll is None:
        return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo mostrar los servicios en este momento (DB)."}
    try:
        query = {}
        # Solo filtro si tipo_servicio tiene un valor y no es la cadena 'none' (que a veces manda el LLM).
        if tipo_servicio and tipo_servicio.lower() != 'none' and tipo_servicio.strip() != "":
            query["tipo_servicio"] = {"$regex": tipo_servicio.strip(), "$options": "i"} # B√∫squeda flexible sin importar may√∫sculas.

        # Pido solo los campos que necesito para mostrar al usuario y para la l√≥gica.
        servicios_encontrados = list(servicios_coll.find(query, {"_id": 0, "id_servicio": 1, "nombre_servicio": 1, "descripcion_servicio": 1, "precio_adicional_servicio": 1, "tipo_servicio": 1}))

        if not servicios_encontrados:
            mensaje = f"No encontr√© servicios o tours del tipo '{tipo_servicio}'." if tipo_servicio and tipo_servicio.lower() != 'none' and tipo_servicio.strip() != "" else "No hay servicios adicionales o tours registrados en este momento."
            session_state["ultima_lista_presentada"] = None # Limpio la √∫ltima lista si no hay resultados.
            return {"status": "servicios_no_encontrados", "mensaje_para_llm": mensaje}

        session_state["ultima_lista_presentada"] = {"tipo": "servicios", "items": servicios_encontrados}
        return {
            "status": "servicios_encontrados",
            "lista_servicios": servicios_encontrados,
            "mensaje_para_llm": (
                "Aqu√≠ tienes una lista de servicios y tours disponibles. Recuerda que los precios indicados son por persona. "
                "Puedes decirme el N√öMERO de la opci√≥n que te interesa (empezando por 1) o su ID (id_servicio) para a√±adirlo a tu reserva, o si quieres ver otro tipo."
            )
        }
    except Exception as e:
        debug_print(f"üî¥ Error en listar_servicios_disponibles: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Problema t√©cnico al listar los servicios."}

def listar_paquetes_disponibles() -> dict:
    """
    Lista los paquetes de alojamiento.
    Guarda la lista en session_state para selecci√≥n num√©rica.
    """
    global session_state
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a listar_paquetes_disponibles()")
    if paquetes_coll is None:
        return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo mostrar los paquetes en este momento (DB)."}
    try:
        # Asumo que en mi DB, los paquetes tienen 'precio_base_paquete_por_noche_persona'.
        paquetes_encontrados = list(paquetes_coll.find({}, {"_id": 0, "id_paquete": 1, "nombre_paquete": 1, "descripcion_paquete": 1, "precio_base_paquete_por_noche_persona": 1, "tipo_logica_paquete": 1}))

        if not paquetes_encontrados:
            session_state["ultima_lista_presentada"] = None
            return {"status": "paquetes_no_encontrados", "mensaje_para_llm": "No hay paquetes de alojamiento registrados en este momento."}

        session_state["ultima_lista_presentada"] = {"tipo": "paquetes", "items": paquetes_encontrados}
        return {
            "status": "paquetes_encontrados",
            "lista_paquetes": paquetes_encontrados,
            "mensaje_para_llm": "Estos son nuestros paquetes de alojamiento. Puedes decirme el N√öMERO del paquete que te interesa (empezando por 1) o su ID (id_paquete) para ver m√°s detalles o seleccionarlo."
        }
    except Exception as e:
        debug_print(f"üî¥ Error en listar_paquetes_disponibles: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Problema t√©cnico al listar los paquetes."}

def listar_reservas_por_usuario(numero_documento_usuario: str) -> dict:
    """Busca todas las reservas de un usuario."""
    global session_state
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a listar_reservas_por_usuario(doc='{numero_documento_usuario}')")

    # Si el LLM no pasa el documento pero el usuario ya est√° identificado en la sesi√≥n, lo uso.
    if not numero_documento_usuario and session_state.get("usuario_identificado"):
        numero_documento_usuario = session_state["usuario_identificado"].get("numero_documento")

    if reservas_coll is None or not numero_documento_usuario:
        return {"status": "error_datos_insuficientes", "mensaje_para_llm": "Necesito tu n√∫mero de documento para buscar tus reservas. Si ya me lo diste, por favor conf√≠rmamelo."}
    try:
        reservas_raw = list(reservas_coll.find({"numero_documento_usuario": numero_documento_usuario}))
        if not reservas_raw:
            return {"status": "reservas_no_encontradas", "mensaje_para_llm": "No encontr√© reservas asociadas a tu n√∫mero de documento."}

        reservas_serializadas = [_serializar_documento_para_llm(r) for r in reservas_raw]
        session_state["ultima_lista_presentada"] = {"tipo": "reservas", "items": reservas_serializadas}
        return {
            "status": "reservas_encontradas", "lista_reservas": reservas_serializadas,
            "mensaje_para_llm": "Aqu√≠ est√°n las reservas que encontr√© para ti. Puedes pedirme detalles de una espec√≠fica usando su N√öMERO en la lista o su ID de reserva."
        }
    except Exception as e:
        debug_print(f"üî¥ Error en listar_reservas_por_usuario: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Problema t√©cnico buscando tus reservas."}

def crear_reserva(
    numero_documento_usuario: str,
    id_paquete_reservado: str,
    fecha_inicio_estadia_str: str,
    fecha_fin_estadia_str: str,
    numero_huespedes: int,
    ids_servicios_solicitados: list[str] = None
) -> dict:
    """
    Crea una solicitud de reserva, incluyendo servicios adicionales y un desglose de costos.
    """
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a crear_reserva para doc: {numero_documento_usuario}, paquete: {id_paquete_reservado}, servicios: {ids_servicios_solicitados}")
    if not all([usuarios_coll, paquetes_coll, reservas_coll, servicios_coll]): # Chequeo conciso de colecciones.
        return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo procesar reservas ahora (DB)."}
    try:
        # --- Validaciones de Entrada ---
        fecha_inicio = datetime.strptime(fecha_inicio_estadia_str, "%Y-%m-%d")
        fecha_fin = datetime.strptime(fecha_fin_estadia_str, "%Y-%m-%d")
        if fecha_fin <= fecha_inicio: return {"status": "error_validacion", "mensaje_para_llm": "La fecha de fin de estad√≠a debe ser posterior a la fecha de inicio."}
        if fecha_inicio < datetime.now().replace(hour=0, minute=0, second=0, microsecond=0): # Comparar solo fechas.
             return {"status": "error_validacion", "mensaje_para_llm": "La fecha de inicio de la estad√≠a no puede ser en el pasado."}
        if numero_huespedes <= 0:
            return {"status": "error_validacion", "mensaje_para_llm": "El n√∫mero de hu√©spedes debe ser al menos 1."}

        # --- Obtener datos de Usuario y Paquete ---
        usuario = usuarios_coll.find_one({"numero_documento": numero_documento_usuario})
        if not usuario: return {"status": "error_usuario_no_encontrado", "mensaje_para_llm": "Usuario no encontrado para la reserva."}

        paquete = paquetes_coll.find_one({"id_paquete": id_paquete_reservado})
        if not paquete: return {"status": "error_paquete_no_encontrado", "mensaje_para_llm": "Paquete no encontrado."}

        # --- Procesar Servicios Adicionales y Calcular sus Costos ---
        servicios_detalle_reserva = []
        costo_total_servicios_por_persona_acumulado = 0
        if ids_servicios_solicitados:
            for id_serv in ids_servicios_solicitados:
                servicio_info = servicios_coll.find_one({"id_servicio": id_serv})
                if servicio_info:
                    precio_sp = servicio_info.get("precio_adicional_servicio", 0)
                    costo_total_servicios_por_persona_acumulado += precio_sp
                    servicios_detalle_reserva.append({
                        "id_servicio": id_serv,
                        "nombre_servicio": servicio_info.get("nombre_servicio"),
                        "precio_por_persona": precio_sp,
                        "costo_estimado_para_grupo": precio_sp * numero_huespedes
                    })
                else:
                    return {"status": "error_validacion", "mensaje_para_llm": f"El servicio con ID '{id_serv}' no es v√°lido."}

        # --- Calcular Costos de Alojamiento y Totales ---
        noches = (fecha_fin - fecha_inicio).days
        if noches <= 0: return {"status": "error_validacion", "mensaje_para_llm": "La estad√≠a debe ser de al menos una noche."}

        precio_paquete_noche_pp = paquete.get("precio_base_paquete_por_noche_persona", 0)
        if precio_paquete_noche_pp == 0: # Advertencia si el precio del paquete es 0.
            debug_print(f"‚ö†Ô∏è Advertencia: El paquete {id_paquete_reservado} tiene precio_base_paquete_por_noche_persona en 0 o no definido.")

        costo_alojamiento_total_grupo = precio_paquete_noche_pp * noches * numero_huespedes
        costo_servicios_adicionales_total_grupo = sum(s['costo_estimado_para_grupo'] for s in servicios_detalle_reserva)
        costo_total_estimado_reserva = costo_alojamiento_total_grupo + costo_servicios_adicionales_total_grupo

        # --- Construir y Guardar el Documento de Reserva ---
        id_nueva_reserva = f"SMRSV-{str(uuid.uuid4())[:8].upper()}"
        documento_reserva = {
            "id_reserva": id_nueva_reserva, "numero_documento_usuario": numero_documento_usuario,
            "nombre_cliente_reserva": usuario.get("nombre_usuario") or usuario.get("nombre_usuario"),
            "id_paquete_reservado": id_paquete_reservado, "nombre_paquete_reservado": paquete.get("nombre_paquete"),
            "fecha_solicitud_reserva": datetime.now(), "fecha_inicio_estadia": fecha_inicio,
            "fecha_fin_estadia": fecha_fin, "numero_huespedes": numero_huespedes, "numero_noches": noches,
            "servicios_adicionales_solicitados": servicios_detalle_reserva,
            "desglose_costos_estimados": {
                "alojamiento_por_noche_persona": precio_paquete_noche_pp,
                "alojamiento_total_grupo": costo_alojamiento_total_grupo,
                "servicios_adicionales_total_grupo": costo_servicios_adicionales_total_grupo,
                "gran_total_estimado": costo_total_estimado_reserva
            },
            "precio_final_pagado": None, "estado_precio": "pendiente_calculo_y_confirmacion",
            "estado_reserva": "solicitada", "notas_adicionales_cliente": ""
        }
        reservas_coll.insert_one(dict(documento_reserva))
        usuarios_coll.update_one({"numero_documento": numero_documento_usuario}, {"$inc": {"numero_reservas_realizadas": 1}})

        reserva_info_llm = _serializar_documento_para_llm(documento_reserva)

        # --- Preparar Mensaje de Confirmaci√≥n para el LLM ---
        desglose_txt = (
            f"Desglose Estimado:\n"
            f"- Alojamiento ({paquete.get('nombre_paquete')} por {noches} noches para {numero_huespedes} personas): {costo_alojamiento_total_grupo:,.0f} COP.\n"
        )
        if servicios_detalle_reserva:
            serv_txt_list = [f"  - {s['nombre_servicio']}: {s['costo_estimado_para_grupo']:,.0f} COP para el grupo ({s['precio_por_persona']:,.0f} COP p/p)." for s in servicios_detalle_reserva]
            desglose_txt += f"- Servicios Adicionales:\n" + "\n".join(serv_txt_list) + "\n"
        desglose_txt += f"- TOTAL ESTIMADO RESERVA: {costo_total_estimado_reserva:,.0f} COP."

        return {
            "status": "reserva_solicitada_exitosamente", "datos_reserva_creada": reserva_info_llm,
            "mensaje_para_llm": (
                f"¬°Solicitud de reserva '{id_nueva_reserva}' registrada para {documento_reserva['nombre_cliente_reserva']}!\n"
                f"{desglose_txt}\n"
                "Un agente confirmar√° disponibilidad y precio final pronto. ¬øAlgo m√°s?"
            )
        }
    except ValueError: # Espec√≠ficamente para errores de formato de fecha.
         return {"status": "error_validacion", "mensaje_para_llm": "El formato de las fechas no es v√°lido. Por favor, usa AAAA-MM-DD."}
    except Exception as e:
        debug_print(f"üî¥ Error en crear_reserva: {str(e)}")
        return {"status": "error_creacion_reserva_db", "mensaje_para_llm": "Problema t√©cnico al crear la solicitud de reserva."}

def obtener_detalle_paquete(id_paquete: str) -> dict:
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a obtener_detalle_paquete(id_paquete='{id_paquete}')")
    if paquetes_coll is None: return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo ver paquetes ahora (DB)."}
    try:
        paquete_raw = paquetes_coll.find_one({"id_paquete": id_paquete})
        if paquete_raw:
            paquete_serializado = _serializar_documento_para_llm(paquete_raw)
            return {"status": "paquete_encontrado", "datos_paquete": paquete_serializado, "mensaje_para_llm": f"Detalles del paquete '{paquete_serializado.get('nombre_paquete', id_paquete)}' listos."}
        return {"status": "paquete_no_encontrado", "mensaje_para_llm": f"Paquete ID '{id_paquete}' no hallado."}
    except Exception as e:
        debug_print(f"üî¥ Error en obtener_detalle_paquete: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Problema t√©cnico buscando paquete."}

def obtener_detalle_habitacion(id_habitacion: str) -> dict:
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a obtener_detalle_habitacion(id_habitacion='{id_habitacion}')")
    if habitaciones_coll is None: return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo ver habitaciones ahora (DB)."}
    try:
        habitacion_raw = habitaciones_coll.find_one({"id_habitacion": id_habitacion})
        if habitacion_raw:
            habitacion_serializada = _serializar_documento_para_llm(habitacion_raw)
            return {"status": "habitacion_encontrada", "datos_habitacion": habitacion_serializada, "mensaje_para_llm": f"Detalles de la habitaci√≥n '{habitacion_serializada.get('nombre_habitacion', id_habitacion)}' listos."}
        return {"status": "habitacion_no_encontrada", "mensaje_para_llm": f"Habitaci√≥n ID '{id_habitacion}' no hallada."}
    except Exception as e:
        debug_print(f"üî¥ Error en obtener_detalle_habitacion: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Problema t√©cnico buscando habitaci√≥n."}

def obtener_detalle_reserva(id_reserva: str) -> dict:
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a obtener_detalle_reserva(id_reserva='{id_reserva}')")
    if reservas_coll is None: return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo ver reservas ahora (DB)."}
    try:
        reserva_raw = reservas_coll.find_one({"id_reserva": id_reserva})
        if reserva_raw:
            reserva_serializada = _serializar_documento_para_llm(reserva_raw)
            return {"status": "reserva_encontrada", "datos_reserva": reserva_serializada, "mensaje_para_llm": f"Detalles de la reserva '{id_reserva}' listos."}
        return {"status": "reserva_no_encontrada", "mensaje_para_llm": f"Reserva ID '{id_reserva}' no hallada."}
    except Exception as e:
        debug_print(f"üî¥ Error en obtener_detalle_reserva: {str(e)}")
        return {"status": "error_busqueda_db", "mensaje_para_llm": "Problema t√©cnico buscando reserva."}

def actualizar_estado_reserva(id_reserva: str, nuevo_estado: str) -> dict:
    debug_print(f"‚öôÔ∏è Colab/Sammy: LLM llam√≥ a actualizar_estado_reserva(id_reserva='{id_reserva}', nuevo_estado='{nuevo_estado}')")
    if reservas_coll is None: return {"status": "error_conexion_db", "mensaje_para_llm": "No puedo actualizar reservas (DB)."}

    ESTADOS_DE_RESERVA_PERMITIDOS = ["solicitada", "pendiente_confirmacion", "confirmada_por_agente", "confirmada_pagada", "cancelada_por_usuario", "cancelada_por_hotel", "completada", "no_show"]
    if nuevo_estado not in ESTADOS_DE_RESERVA_PERMITIDOS:
        return {"status": "error_validacion_estado", "mensaje_para_llm": f"Estado '{nuevo_estado}' no es v√°lido."}
    try:
        reserva_existente = reservas_coll.find_one({"id_reserva": id_reserva})
        if not reserva_existente: return {"status": "reserva_no_encontrada", "mensaje_para_llm": f"Reserva ID '{id_reserva}' no hallada para actualizar."}
        if reserva_existente.get("estado_reserva") == nuevo_estado:
            return {"status": "sin_cambios_necesarios", "mensaje_para_llm": f"Reserva '{id_reserva}' ya estaba en estado '{nuevo_estado}'."}

        resultado = reservas_coll.update_one(
            {"id_reserva": id_reserva},
            {"$set": {"estado_reserva": nuevo_estado, "fecha_ultima_modificacion": datetime.now()}}
        )
        if resultado.modified_count > 0:
            return {
                "status": "reserva_actualizada_exitosamente",
                "id_reserva_actualizada": id_reserva,
                "nuevo_estado_reserva": nuevo_estado,
                "mensaje_para_llm": f"Reserva '{id_reserva}' actualizada a '{nuevo_estado}'."
            }
        return {"status": "reserva_no_modificada", "mensaje_para_llm": f"Reserva '{id_reserva}' no fue modificada."}
    except Exception as e:
        debug_print(f"üî¥ Error en actualizar_estado_reserva: {str(e)}")
        return {"status": "error_actualizacion_db", "mensaje_para_llm": "Problema t√©cnico actualizando reserva."}

# Esta es la lista de todas las funciones que mi LLM (Sammy) podr√° utilizar.
# Es importante que los nombres aqu√≠ coincidan exactamente con c√≥mo defin√≠ las funciones arriba.
herramientas_disponibles_colab = [
    Bienvenida_cliente,
    verificar_o_registrar_usuario,
    registrar_nuevo_usuario,
    listar_servicios_disponibles,
    listar_paquetes_disponibles,
    listar_reservas_por_usuario, # ¬°Nueva! Para que Sammy pueda buscar las reservas de un usuario.
    crear_reserva,
    obtener_detalle_paquete,
    obtener_detalle_habitacion,
    obtener_detalle_reserva,
    actualizar_estado_reserva
]

# Celda 5: Funci√≥n de Inicializaci√≥n Principal para Colab
# ---------------------------------------------------------------------------
def inicializar_app_colab():
    """
    Esta funci√≥n es como el "arranque" de mi aplicaci√≥n en Colab.
    Se encarga de conectar a MongoDB y configurar el modelo Gemini.
    Devuelve True si todo va bien, False si algo falla.
    """
    global client_mongo, db, usuarios_coll, servicios_coll, paquetes_coll, habitaciones_coll, reservas_coll
    global model_gemini, chat_session_sammy, session_state # session_state tambi√©n es global.

    debug_print("Colab App: Iniciando configuraci√≥n global...")
    # Reseteo el estado de la sesi√≥n cada vez que inicializo, para una conversaci√≥n limpia.
    session_state = {"bienvenida_dada": False, "ultima_lista_presentada": None, "usuario_identificado": None}

    # Verifico que tenga la URI de MongoDB.
    if not MONGODB_URI:
        print("‚ÄºÔ∏è Colab App ERROR: MONGODB_ATLAS_URI no configurada en Secrets de Colab.")
        # Si falta, no puedo continuar, as√≠ que reseteo todo a None.
        client_mongo = db = usuarios_coll = servicios_coll = paquetes_coll = habitaciones_coll = reservas_coll = None
        model_gemini = chat_session_sammy = None
        return False

    # Intento conectar a MongoDB.
    try:
        client_mongo = MongoClient(MONGODB_URI, server_api=ServerApi('1'))
        client_mongo.admin.command('ping') # Hago un ping para confirmar la conexi√≥n.
        db = client_mongo[DB_NAME_PRINCIPAL]
        # Asigno cada colecci√≥n a su variable global para usarlas f√°cilmente despu√©s.
        usuarios_coll = db[COLL_USUARIOS_NAME]
        servicios_coll = db[COLL_SERVICIOS_NAME]
        paquetes_coll = db[COLL_PAQUETES_NAME]
        habitaciones_coll = db[COLL_HABITACIONES_NAME]
        reservas_coll = db[COLL_RESERVAS_NAME]
        debug_print("‚úÖ Colab App: Conexi√≥n a MongoDB establecida y colecciones referenciadas.")
    except Exception as e:
        print(f"‚ÄºÔ∏è Colab App ERROR conectando a MongoDB: {e}") # Muestro el error si falla.
        client_mongo = db = usuarios_coll = servicios_coll = paquetes_coll = habitaciones_coll = reservas_coll = None
        model_gemini = chat_session_sammy = None
        return False

    # Intento configurar Gemini.
    try:
        if not GEMINI_API_KEY: # Verifico que tenga la API Key de Gemini.
            print("‚ÄºÔ∏è Colab App ERROR: GEMINI_API_KEY no configurada en Secrets de Colab.")
            model_gemini = chat_session_sammy = None
            return False

        genai.configure(api_key=GEMINI_API_KEY) # Configuro la librer√≠a de Gemini.

        # Esta es la instrucci√≥n de sistema completa y detallada para Sammy.
        # Le dice c√≥mo comportarse, qu√© herramientas usar y c√≥mo manejar diferentes situaciones.
        instruccion_sistema_completa = (
            "Eres Sammy, un asistente virtual excepcionalmente amigable, profesional y muy servicial del 'Hotel Para√≠so Caribe√±o', "
            "ubicado en la hermosa ciudad de Santa Marta, Colombia. Tu principal objetivo es ayudar a los clientes con sus consultas "
            "y solicitudes relacionadas con el hotel de manera eficiente, clara y cort√©s. Mant√©n siempre un tono positivo y proactivo."
            "\n\n"
            "**Flujo General de la Conversaci√≥n y Uso de Herramientas:**"
            "\n\n"
            "1.  **Inicio de Conversaci√≥n:** Cuando un usuario inicie una nueva conversaci√≥n (ej. 'Hola'), "
            "    SIEMPRE debes comenzar utilizando la herramienta `Bienvenida_cliente`. Esta te guiar√° sobre qu√© informaci√≥n solicitar (nombre completo y luego n√∫mero de documento)."
            "\n\n"
            "2.  **Identificaci√≥n del Usuario:**"
            "    * Una vez que el usuario te proporcione su nombre y n√∫mero de documento, utiliza la herramienta `verificar_o_registrar_usuario`."
            "    * **Si `status: 'usuario_encontrado'`:** Saluda al usuario por su nombre y preg√∫ntale c√≥mo puedes ayudarle. Evita repetir el saludo completo de bienvenida si ya se dio."
            "    * **Si `status: 'usuario_no_encontrado_pedir_nombre'`:** Pide el nombre completo."
            "    * **Si `status: 'usuario_no_encontrado_proceder_registro'`:** Informa al usuario que lo vas a registrar (ya que tienes nombre y documento) y llama a `registrar_nuevo_usuario`."
            "\n\n"
            "3.  **Consultas de Informaci√≥n:**"
            "    * **Para paquetes de alojamiento:** Si el usuario pregunta 'qu√© paquetes hay', 'opciones de paquetes', o similar, usa `listar_paquetes_disponibles`. Para detalles de uno espec√≠fico, usa `obtener_detalle_paquete`."
            "    * **Para habitaciones individuales:** Usa `obtener_detalle_habitacion`."
            "    * **Para servicios adicionales o tours:** Si el usuario pregunta por estos, usa `listar_servicios_disponibles`. Puedes ofrecer filtrar por `tipo_servicio` (ej. 'tour', 'alimentacion'). Presenta la lista numerada (1, 2, 3...) y recuerda que el precio es por persona. Pide que elijan por N√öMERO o ID."
            "    * **Para reservas del usuario:** Si el usuario pregunta por 'mis reservas' y ya est√° identificado (verifica el estado de sesi√≥n), usa `listar_reservas_por_usuario` con su `numero_documento_usuario`. Si no est√° identificado, primero identif√≠calo. Si no recuerda un ID espec√≠fico, esta funci√≥n le mostrar√° todas sus reservas y podr√° seleccionar una por n√∫mero o ID."
            "    * **Para detalles de una reserva espec√≠fica:** Usa `obtener_detalle_reserva` con el `id_reserva`."
            "\n\n"
            "4.  **Crear una Nueva Reserva:**"
            "    a.  Gu√≠a al usuario para elegir un paquete (usando `listar_paquetes_disponibles` y `obtener_detalle_paquete`)."
            "    b.  PREGUNTA si desea a√±adir servicios/tours. Si s√≠, usa `listar_servicios_disponibles`. Presenta opciones numeradas. Pide que elija por N√öMERO o ID."
            "    c.  Recolecta: `id_paquete_reservado`, `fecha_inicio_estadia_str` (AAAA-MM-DD), `fecha_fin_estadia_str` (AAAA-MM-DD), `numero_huespedes`, y lista de `ids_servicios_solicitados`."
            "    d.  ANTES de llamar a `crear_reserva`, resume todos los detalles: paquete (nombre), fechas (N noches), hu√©spedes, servicios adicionales (nombre y costo estimado total para el grupo, aclarando precio p/p), costo estimado del alojamiento (precio_paquete_noche_pp * noches * hu√©spedes), y costo TOTAL ESTIMADO de la reserva. Pide confirmaci√≥n."
            "    e.  Si confirma, llama a `crear_reserva`."
            "    f.  Informa el resultado, incluyendo el ID de la reserva y el desglose de costos, enfatizando que es 'solicitud' pendiente de confirmaci√≥n."
            "\n\n"
            "5.  **Actualizar Estado de una Reserva:** Usa `actualizar_estado_reserva`. Pide confirmaci√≥n."
            "\n\n"
            "**Principios Generales:**"
            "    * Espera resultados de herramientas. No supongas."
            "    * Maneja errores amigablemente."
            "    * Recolecta par√°metros ANTES de llamar herramientas."
            "    * Si el usuario da un N√öMERO para seleccionar de una lista que presentaste, intenta identificar el ID correspondiente. Si no est√°s seguro, PIDE CONFIRMACI√ìN del nombre o ID del √≠tem antes de usarlo en otra herramienta."
            "    * S√© claro, preciso, conversacional. Prioriza herramientas. No inventes informaci√≥n."
            "    * **MUY IMPORTANTE: Cuando una herramienta te devuelve datos (ej., una lista de paquetes o el resultado de una acci√≥n), NUNCA muestres el resultado JSON crudo (como 'tool_outputs' o el diccionario Python) al usuario. En su lugar, USA la informaci√≥n de ese resultado para FORMULAR una respuesta completa y amigable en lenguaje natural para el usuario, presentando los datos de forma legible y √∫til.**"
        )
        model_gemini = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            tools=herramientas_disponibles_colab,
            system_instruction=instruccion_sistema_completa
        )
        # Inicio la sesi√≥n de chat. enable_automatic_function_calling=False me da m√°s control.
        chat_session_sammy = model_gemini.start_chat(enable_automatic_function_calling=False)
        debug_print("‚úÖ Colab App: Modelo Gemini configurado y sesi√≥n de chat lista.")
    except Exception as e:
        print(f"‚ÄºÔ∏è Colab App ERROR configurando Gemini: {e}") # Muestro el error si falla.
        model_gemini = chat_session_sammy = None
        return False
    return True

# Celda 6: Funci√≥n para Procesar Mensajes en Colab
# ---------------------------------------------------------------------------
def procesar_mensaje_colab(mensaje_usuario_actual: str) -> str:
    """
    Esta es la funci√≥n principal que maneja la conversaci√≥n.
    Env√≠a el mensaje del usuario a Gemini, gestiona las llamadas a herramientas
    y devuelve la respuesta final de Sammy.
    """
    global chat_session_sammy, session_state

    if not model_gemini: # Verifico si el modelo de Gemini est√° listo.
        return "Lo siento, el asistente no est√° disponible en este momento (error de modelo)."

    # Si la sesi√≥n de chat no existe (ej. primera vez o si se perdi√≥), intento crearla/reiniciarla.
    if not chat_session_sammy:
        try:
            chat_session_sammy = model_gemini.start_chat(enable_automatic_function_calling=False)
            # Reseteo el estado de la sesi√≥n para una conversaci√≥n limpia.
            session_state = {"bienvenida_dada": False, "ultima_lista_presentada": None, "usuario_identificado": None}
            debug_print("‚úÖ Colab/Sammy: Nueva sesi√≥n de chat creada.")
        except Exception as e_chat_restart:
            debug_print(f"üî¥ Colab/Sammy: No se pudo reiniciar la sesi√≥n de chat: {e_chat_restart}")
            return "Lo siento, estoy teniendo problemas para iniciar nuestra conversaci√≥n. Por favor, intenta m√°s tarde."

    debug_print(f"\nüë§ T√∫ (Colab) envi√≥: {mensaje_usuario_actual}") # Log del mensaje del usuario.
    current_response_from_llm = None # Para guardar la respuesta actual del LLM.

    try:
        # L√≥gica para mapear una selecci√≥n num√©rica del usuario a un ID, si aplica.
        # Esto es para cuando Sammy presenta una lista numerada y el usuario responde con un n√∫mero.
        if session_state.get("ultima_lista_presentada") and mensaje_usuario_actual.strip().isdigit():
            lista_info = session_state["ultima_lista_presentada"]
            try:
                indice_seleccionado = int(mensaje_usuario_actual.strip()) - 1 # Convierto a √≠ndice base 0.

                if 0 <= indice_seleccionado < len(lista_info["items"]):
                    item_seleccionado = lista_info["items"][indice_seleccionado]
                    id_campo_map = {"paquetes": "id_paquete", "servicios": "id_servicio", "reservas": "id_reserva"}
                    id_campo = id_campo_map.get(lista_info["tipo"])

                    if id_campo and id_campo in item_seleccionado:
                        id_seleccionado = item_seleccionado.get(id_campo)
                        nombre_item = item_seleccionado.get("nombre_paquete") or item_seleccionado.get("nombre_servicio") or item_seleccionado.get("id_reserva")

                        # Modifico el mensaje del usuario para que el LLM entienda la selecci√≥n por ID.
                        mensaje_usuario_actual = f"He seleccionado el √≠tem con ID '{id_seleccionado}' ({nombre_item}). Por favor, procede con esto."
                        debug_print(f"‚ÑπÔ∏è Colab/Sammy: Usuario seleccion√≥ por n√∫mero, mapeado a: {mensaje_usuario_actual}")
                        session_state["ultima_lista_presentada"] = None # Limpio la lista despu√©s de la selecci√≥n.
                    else:
                        debug_print(f"‚ö†Ô∏è Colab/Sammy: No se pudo encontrar el campo ID ('{id_campo}') en el item seleccionado.")
                else:
                    debug_print(f"‚ö†Ô∏è Colab/Sammy: Selecci√≥n num√©rica '{mensaje_usuario_actual}' fuera de rango.")
            except ValueError: # Si la entrada no era un n√∫mero v√°lido.
                debug_print(f"‚ö†Ô∏è Colab/Sammy: No se pudo convertir la entrada num√©rica '{mensaje_usuario_actual}'.")

        # Env√≠o el mensaje (original o modificado) al LLM.
        current_response_from_llm = chat_session_sammy.send_message(mensaje_usuario_actual)

        # Bucle para manejar el flujo de "function calling".
        # El LLM puede decidir llamar a varias funciones seguidas si lo necesita.
        while True:
            # Accedo de forma segura a la posible llamada a funci√≥n en la respuesta del LLM.
            candidate = current_response_from_llm.candidates[0] if current_response_from_llm.candidates and len(current_response_from_llm.candidates) > 0 else None
            if not candidate or not candidate.content or not candidate.content.parts:
                debug_print("üî¥ Colab/Sammy: Respuesta inesperada del LLM sin candidatos o partes v√°lidas.")
                break # Salgo del bucle si la estructura de respuesta no es la esperada.

            part_with_potential_call = candidate.content.parts[0]
            function_call = part_with_potential_call.function_call if hasattr(part_with_potential_call, 'function_call') and part_with_potential_call.function_call.name else None

            if not function_call: # Si no hay m√°s llamadas a funci√≥n, salgo del bucle.
                break

            function_name = function_call.name
            function_args_dict = dict(function_call.args) # Convierto los argumentos a un diccionario.

            # L√≥gica para a√±adir 'nombre_completo' si el usuario ya est√° identificado
            # y el LLM llama a 'verificar_o_registrar_usuario' solo con el documento.
            if function_name == "verificar_o_registrar_usuario" and \
               session_state.get("usuario_identificado") and \
               "numero_documento" in function_args_dict and \
               not function_args_dict.get("nombre_completo"):
                usuario_identificado_data = session_state["usuario_identificado"]
                function_args_dict["nombre_completo"] = usuario_identificado_data.get("nombre_usuario") or usuario_identificado_data.get("nombrre_usuario")

            args_str = f" con args: {function_args_dict}" if function_args_dict else ""
            debug_print(f"‚öôÔ∏è Colab/Sammy: LLM quiere llamar a: {function_name}{args_str}")

            # Verifico si la funci√≥n solicitada por el LLM existe en mi c√≥digo y es llamable.
            if function_name in globals() and callable(globals()[function_name]):
                funcion_a_llamar = globals()[function_name]
                resultado_funcion_dict = {} # Inicializo el resultado.
                try:
                    # Ejecuto la funci√≥n herramienta con los argumentos que me dio el LLM.
                    resultado_funcion_dict = funcion_a_llamar(**function_args_dict)
                except Exception as e_func:
                    debug_print(f"üî¥ Error al ejecutar la funci√≥n '{function_name}' desde Colab: {e_func}")
                    resultado_funcion_dict = {"error_interno_python": f"Al ejecutar {function_name}: {str(e_func)}"}

                debug_print(f"‚û°Ô∏è Resultado de '{function_name}' (Colab): {resultado_funcion_dict}")

                # Env√≠o el resultado de mi funci√≥n de vuelta al LLM.
                function_response_part_to_send = glm.Part(
                    function_response=glm.FunctionResponse(name=function_name, response=resultado_funcion_dict)
                )
                current_response_from_llm = chat_session_sammy.send_message(content=function_response_part_to_send) # Actualizo la respuesta actual.
            else: # Si la funci√≥n que el LLM quiere llamar no la tengo definida.
                debug_print(f"üî¥ Error: Herramienta '{function_name}' no encontrada en Colab.")
                error_payload = {"error_herramienta_no_encontrada": f"La herramienta solicitada '{function_name}' no est√° implementada."}
                function_response_part_error_to_send = glm.Part(
                    function_response=glm.FunctionResponse(name=function_name, response=error_payload)
                )
                current_response_from_llm = chat_session_sammy.send_message(content=function_response_part_error_to_send)

        # Despu√©s del bucle (cuando ya no hay m√°s llamadas a funci√≥n), la respuesta final deber√≠a ser texto.
        # Extraigo el texto de todas las partes de la respuesta del candidato.
        final_text_response = ""
        if current_response_from_llm and current_response_from_llm.candidates:
            for part in current_response_from_llm.candidates[0].content.parts:
                # Me aseguro de que la parte sea texto y no una FunctionCall residual.
                if hasattr(part, 'text') and part.text:
                    final_text_response += part.text
                elif hasattr(part, 'function_call') and part.function_call.name:
                    debug_print(f"‚ö†Ô∏è Colab/Sammy: Se encontr√≥ una FunctionCall inesperada ('{part.function_call.name}') al obtener la respuesta de texto final.")

        final_text_response = final_text_response.strip() # Limpio espacios extra.

        if final_text_response:
            return final_text_response
        else: # Si no hay texto, puede ser un error o una respuesta bloqueada.
            debug_print("üî¥ Colab/Sammy: LLM no proporcion√≥ una respuesta de texto final legible o la respuesta estaba vac√≠a.")
            if current_response_from_llm and hasattr(current_response_from_llm, 'prompt_feedback') and current_response_from_llm.prompt_feedback.block_reason:
                 return f"Lo siento, no pude procesar completamente tu solicitud debido a: {current_response_from_llm.prompt_feedback.block_reason_message or current_response_from_llm.prompt_feedback.block_reason}"
            return "Entendido. ¬øHay algo m√°s en lo que pueda ayudarte o necesitas que aclare algo?" # Mensaje gen√©rico.

    except Exception as e_convo:
        debug_print(f"üî¥ Error general en procesar_mensaje_colab: {e_convo}")
        error_message_from_llm = "Lo siento, tuve un problema procesando tu solicitud general en este momento."
        # Intento dar una respuesta de error m√°s informativa si es posible.
        if current_response_from_llm and current_response_from_llm.candidates and current_response_from_llm.candidates[0].finish_reason != 1: # 1 es 'STOP'
             error_message_from_llm = f"El asistente no pudo completar la respuesta (Raz√≥n: {current_response_from_llm.candidates[0].finish_reason}). Intenta de nuevo."
        elif current_response_from_llm and hasattr(current_response_from_llm, 'prompt_feedback') and current_response_from_llm.prompt_feedback.block_reason:
             error_message_from_llm = f"Tu solicitud fue bloqueada por: {current_response_from_llm.prompt_feedback.block_reason_message or current_response_from_llm.prompt_feedback.block_reason}"

        if current_response_from_llm and current_response_from_llm.candidates and current_response_from_llm.candidates[0].content:
             debug_print(f"   √öltima respuesta del LLM (partes): {current_response_from_llm.candidates[0].content.parts}")
        return error_message_from_llm

# Celda 7: Interfaz Gr√°fica con ipywidgets y L√≥gica de Chat
# ---------------------------------------------------------------------------
import html

print("\n--- Configurando Interfaz Gr√°fica para Sammy ---")

chat_html_style = """
<style>
    .chat-message { margin-bottom: 10px; padding: 8px 12px; border-radius: 12px; max-width: 85%; word-wrap: break-word; line-height: 1.4; font-size: 0.95em; box-shadow: 0 1px 2px rgba(0,0,0,0.1); color: #000000 !important; }
    .user-message { background-color: #DCF8C6; margin-left: auto; text-align: left; align-self: flex-end; border: 1px solid #c5e7b3;}
    .user-message strong { color: #075E54; }
    .sammy-message { background-color: #E9E9EB; margin-right: auto; text-align: left; align-self: flex-start; border: 1px solid #dcdcdc;}
    .sammy-message strong { color: #1F4E79; }
    .error-message { background-color: #FFDDEE; color: #D8000C !important; border: 1px solid #FFBABA; align-self: flex-start;}
    .error-message strong { color: #B00020; }
    .chat-output-container { border: 1px solid #AAB8C2; padding: 15px; height: 450px; overflow-y: auto; display: flex; flex-direction: column-reverse; background-color: #ffffff; border-radius: 8px; }
    .chat-messages-inner { display: flex; flex-direction: column; }
    .chat-messages-inner strong { font-weight: 600; }
    .chat-messages-inner i { color: #555; }
    .input-box { margin-top: 10px; }
</style>
"""
display(HTML(chat_html_style))

chat_output_html = widgets.HTML(value="<div class='chat-messages-inner'></div>", layout=widgets.Layout(height='450px', border='1px solid #ccc', overflow_y='auto', width='100%', padding='5px'))
user_input_field = widgets.Text(value='', placeholder='Escribe tu mensaje a Sammy aqu√≠...', description='', disabled=True, layout=widgets.Layout(width='calc(100% - 105px)'))
send_button = widgets.Button(description='Enviar', disabled=True, button_style='info', tooltip='Enviar mensaje a Sammy', icon='paper-plane', layout=widgets.Layout(width='95px'))

conversation_history_html_ui = []
is_processing_message_ui = False

def add_message_to_ui(raw_text: str, sender_class: str):
    global conversation_history_html_ui # Necesario para modificar la lista global
    prefix = ""
    content_to_display = raw_text
    if raw_text.startswith("<strong>T√∫:</strong>"):
        prefix = "<strong>T√∫:</strong> "
        message_content = raw_text.replace(prefix, "").strip()
        content_to_display = html.escape(message_content).replace('\n', '<br>')
    elif raw_text.startswith("<strong>ü§ñ Sammy:</strong>"):
        prefix = "<strong>ü§ñ Sammy:</strong> "
        message_content = raw_text.replace(prefix, "").strip()
        content_to_display = message_content.replace('\n', '<br>')
    elif raw_text.startswith("<strong>Sistema:</strong>"):
        prefix = "<strong>Sistema:</strong> "
        message_content = raw_text.replace(prefix, "").strip()
        content_to_display = html.escape(message_content).replace('\n', '<br>')
    else:
        content_to_display = html.escape(raw_text).replace('\n', '<br>')

    full_message_html = f"{prefix}{content_to_display}"
    conversation_history_html_ui.insert(0, f"<div class='chat-message {sender_class}'>{full_message_html}</div>")
    chat_output_html.value = f"<div class='chat-messages-inner'>{''.join(conversation_history_html_ui)}</div>"

def on_send_button_clicked_ui(b=None):
    global is_processing_message_ui, conversation_history_html_ui # Declarar global aqu√≠
    if is_processing_message_ui: return

    user_message = user_input_field.value
    if not user_message.strip(): return

    add_message_to_ui(f"<strong>T√∫:</strong> {user_message}", "user-message")
    current_input = user_input_field.value
    user_input_field.value = ''

    is_processing_message_ui = True
    original_button_description = send_button.description
    original_button_icon = send_button.icon
    user_input_field.disabled = True
    send_button.disabled = True
    send_button.description = "..."
    send_button.icon = "spinner"

    add_message_to_ui("<strong>ü§ñ Sammy:</strong> <i>Est√° pensando...</i>", "sammy-message")

    try:
        sammy_response = procesar_mensaje_colab(current_input)

        # Quitar el mensaje de "pensando..." de forma segura
        conversation_history_html_ui = [msg for msg in conversation_history_html_ui if "<i>Est√° pensando...</i>" not in msg]
        chat_output_html.value = f"<div class='chat-messages-inner'>{''.join(conversation_history_html_ui)}</div>" # Actualizar UI

        add_message_to_ui(f"<strong>ü§ñ Sammy:</strong> {sammy_response}", "sammy-message")

    except Exception as e:
        conversation_history_html_ui = [msg for msg in conversation_history_html_ui if "<i>Est√° pensando...</i>" not in msg]
        chat_output_html.value = f"<div class='chat-messages-inner'>{''.join(conversation_history_html_ui)}</div>" # Actualizar UI
        add_message_to_ui(f"<strong>Sistema:</strong> Error al procesar: {str(e)}", "error-message")
        debug_print(f"üî¥ Error en UI durante procesar_mensaje_colab: {e}")
    finally:
        user_input_field.disabled = False
        send_button.disabled = False
        send_button.description = original_button_description
        send_button.icon = original_button_icon
        is_processing_message_ui = False

send_button.on_click(on_send_button_clicked_ui)
user_input_field.on_submit(on_send_button_clicked_ui)

print("\n--- Iniciando Asistente Sammy para Hotel Para√≠so Caribe√±o (Colab con UI) ---")

if inicializar_app_colab():
    print("\n‚úÖ ¬°Todo listo! Puedes empezar a chatear con Sammy usando la interfaz de abajo.")

    user_input_field.disabled = False
    send_button.disabled = False

    add_message_to_ui("<strong>ü§ñ Sammy:</strong> <i>Iniciando conversaci√≥n...</i>", "sammy-message")

    try:
        initial_bot_response = procesar_mensaje_colab("Hola Sammy, por favor inicia la bienvenida.")
        conversation_history_html_ui = [msg for msg in conversation_history_html_ui if "<i>Iniciando conversaci√≥n...</i>" not in msg]
        chat_output_html.value = f"<div class='chat-messages-inner'>{''.join(conversation_history_html_ui)}</div>" # Actualizar UI

        if initial_bot_response:
            add_message_to_ui(f"<strong>ü§ñ Sammy:</strong> {initial_bot_response}", "sammy-message")
        else:
            add_message_to_ui("<strong>Sistema:</strong> No se pudo obtener el saludo inicial de Sammy.", "error-message")
    except NameError as ne:
        conversation_history_html_ui = [msg for msg in conversation_history_html_ui if "<i>Iniciando conversaci√≥n...</i>" not in msg]
        chat_output_html.value = f"<div class='chat-messages-inner'>{''.join(conversation_history_html_ui)}</div>" # Actualizar UI
        add_message_to_ui(f"<strong>Sistema:</strong> Error de configuraci√≥n: {str(ne)}. Aseg√∫rate de ejecutar todas las celdas.", "error-message")
        debug_print(f"üî¥ Error en UI durante la bienvenida inicial (NameError): {ne}")
    except Exception as e_init_chat:
        conversation_history_html_ui = [msg for msg in conversation_history_html_ui if "<i>Iniciando conversaci√≥n...</i>" not in msg]
        chat_output_html.value = f"<div class='chat-messages-inner'>{''.join(conversation_history_html_ui)}</div>" # Actualizar UI
        add_message_to_ui(f"<strong>Sistema:</strong> Error al iniciar el chat: {str(e_init_chat)}", "error-message")
        debug_print(f"üî¥ Error en UI durante la bienvenida inicial: {e_init_chat}")

    input_area = widgets.HBox([user_input_field, send_button])
    display(chat_output_html, input_area)
else:
    print("\nüî¥ FALL√ì LA INICIALIZACI√ìN. No se puede iniciar el chat. Revisa los mensajes de error de las celdas anteriores.")